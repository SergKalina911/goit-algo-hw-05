"""                                         Третє завдання (не обов'язкове)

    Розробіть Python-скрипт для аналізу файлів логів. Скрипт повинен вміти читати лог-файл, переданий 
як аргумент командного рядка, і виводити статистику за рівнями логування наприклад, INFO, ERROR, DEBUG. 
Також користувач може вказати рівень логування як другий аргумент командного рядка, щоб отримати всі 
записи цього рівня.
    Файли логів – це файли, що містять записи про події, які відбулися в операційній системі, 
програмному забезпеченні або інших системах. Вони допомагають відстежувати та аналізувати поведінку 
системи, виявляти та діагностувати проблеми.
    Для виконання завдання візьміть наступний приклад лог-файлу:

2024-01-22 08:30:01 INFO User logged in successfully.
2024-01-22 08:45:23 DEBUG Attempting to connect to the database.
2024-01-22 09:00:45 ERROR Database connection failed.
2024-01-22 09:15:10 INFO Data export completed.
2024-01-22 10:30:55 WARNING Disk usage above 80%.
2024-01-22 11:05:00 DEBUG Starting data backup process.
2024-01-22 11:30:15 ERROR Backup process failed.
2024-01-22 12:00:00 INFO User logged out.
2024-01-22 12:45:05 DEBUG Checking system health.
2024-01-22 13:30:30 INFO Scheduled maintenance.

                        Вимоги до завдання:

    1. Скрипт повинен приймати шлях до файлу логів як аргумент командного рядка.
    2. Скрипт повинен приймати не обов'язковий аргумент командного рядка, після аргументу шляху до файлу 
    логів. Він відповідає за виведення всіх записи певного рівня логування. І приймає значення 
    відповідно до рівня логування файлу. Наприклад аргумент error виведе всі записи рівня ERROR з файлу 
    логів.
    3. Скрипт має зчитувати і аналізувати лог-файл, підраховуючи кількість записів для кожного рівня 
    логування (INFO, ERROR, DEBUG, WARNING).
    4. Реалізуйте функцію parse_log_line(line: str) -> dict для парсингу рядків логу.
    5. Реалізуйте функцію load_logs(file_path: str) -> list для завантаження логів з файлу.
    6. Реалізуйте функцію filter_logs_by_level(logs: list, level: str) -> list для фільтрації логів за 
    рівнем.
    7. Реалізуйте функцію count_logs_by_level(logs: list) -> dict для підрахунку записів за рівнем 
    логування.
    8. Результати мають бути представлені у вигляді таблиці з кількістю записів для кожного рівня. 
    Для цього реалізуйте функцію display_log_counts(counts: dict), яка форматує та виводить результати. 
    Вона приймає результати виконання функції count_logs_by_level.

                        Рекомендації для виконання:

    1. Перш ніж почати, ознайомтеся зі структурою вашого лог-файлу. Зверніть увагу на формат дати та 
    часу, рівні логування INFO, ERROR, DEBUG, WARNING і структуру повідомлень.
    2. Зрозумійте, як розділені різні компоненти логу, це зазвичай пробіли або спеціальні символи.
    3. Розділіть ваше завдання на логічні блоки і функції для кращої читабельності і подальшого 
    розширення.
    4. Парсинг рядка логу виконує функцію parse_log_line(line: str) -> dict, яка приймає рядок з логу 
    як вхідний параметр і повертає словник з розібраними компонентами: дата, час, рівень, повідомлення. 
    Використовуйте методи рядків, такі як split(), для розділення рядка на частини.
    5. Завантаження лог-файлів виконує функція load_logs(file_path: str) -> list, що відкриває файл, 
    читає кожен рядок і застосовує до нього функцію parse_log_line, зберігаючи результати в список.
    6. Фільтрацію за рівнем логування виконує функція filter_logs_by_level(logs: list, level: str) -> 
    list. Вона дозволить вам отримати всі записи логу для певного рівня логування.
    7. Підрахунок записів за рівнем логування повинна робити функція count_logs_by_level(logs: list) -> 
    dict, яка проходить по всім записам і підраховує кількість записів для кожного рівня логування.
    8. Виведення результатів виконайте за допомоги функції display_log_counts(counts: dict), яка 
    форматує та виводить результати підрахунку в читабельній формі.
    9. Ваш скрипт повинен вміти обробляти різні види помилок, такі як відсутність файлу або помилки при 
    його читанні. Використовуйте блоки try/except для обробки виняткових ситуацій.
    
                        Критерії оцінювання:

    1. Скрипт виконує всі зазначені вимоги, правильно аналізуючи лог-файли та виводячи інформацію.
    2. Скрипт коректно обробляє помилки, такі як неправильний формат лог-файлу або відсутність файлу.
    3. При розробці обов'язково було використано один з елементів функціонального програмування: 
    лямбда-функція, списковий вираз, функція filter, тощо.
    4. Код добре структурований, зрозумілий і містить коментарі там, де це необхідно.


                        Приклад використання:

    При запуску скрипту
    
    # python [main.py](<http://main.py/>) /path/to/logfile.log

ми повинні очікувати таке виведення:
Рівень логування | Кількість
-----------------|----------
INFO             | 4
DEBUG            | 3
ERROR            | 2
WARNING          | 1

    Якщо користувач хоче переглянути всі записи певного рівня логування, він може запустити скрипт з 
додатковим аргументом, наприклад:

# python main.py path/to/logfile.log error

Це виведе загальну статистику за рівнями, а також детальну інформацію для всіх записів з рівнем ERROR.
Рівень логування | Кількість
-----------------|----------
INFO             | 4
DEBUG            | 3
ERROR            | 2
WARNING          | 1

Деталі логів для рівня 'ERROR':
2024-01-22 09:00:45 - Database connection failed.
2024-01-22 11:30:15 - Backup process failed.
"""
def parse_log_line(line: str) -> dict:
    """ Функція для розбору рядка логу на компоненти.
    Параметри:
    line (str): Рядок з логу, який потрібно розібрати.
    Повертає:
    dict: Словник з розібраними компонентами: дата, час, рівень, повідомлення."""
    
    parts = line.split(' ', 3)  # Розділяємо рядок на 4 частини
    # Перевіряємо, чи достатньо частин для розбору
    # Якщо частин менше 4, виводимо помилку
    if len(parts) < 4:
        raise ValueError("Log line is not in the expected format.")
    # Повертаємо словник з розібраними компонентами
    # Перші дві частини - дата та час, третя - рівень
    return {
        'date': parts[0],
        'time': parts[1],
        'level': parts[2],
        'message': parts[3]
    }

def load_logs(file_path: str) -> list:
    """ Функція для завантаження логів з файлу.
    Параметри:
    file_path (str): Шлях до файлу з логами.
    Повертає:
    list: Список словників, кожен з яких містить розібраний рядок логу."""
    # Ініціалізуємо список для зберігання розібраних логів
    logs = []
    # Відкриваємо файл з логами для читання
    # Використовуємо контекстний менеджер для автоматичного закриття файлу
    # Читаємо кожен рядок з файлу, обрізаємо пробіли
    # та додаємо розібраний рядок до списку logs
    # Використовуємо метод strip() для видалення пробілів на початку та в кінці рядка
    with open(file_path, 'r') as file:
        for line in file:
            # Додаємо розібраний рядок до списку logs
            # Викликаємо функцію parse_log_line для розбору рядка
            logs.append(parse_log_line(line.strip()))
    # Повертаємо список розібраних логів
    return logs

def filter_logs_by_level(logs: list, level: str) -> list:
    """ Функція для фільтрації логів за рівнем.
    Параметри:
    logs (list): Список логів, кожен з яких є словником.
    level (str): Рівень логування, за яким потрібно фільтрувати.
    Повертає:
    list: Список логів, відфільтрованих за вказаним рівнем."""
    # Повертаємо список логів, де рівень логування збігається з вказаним рівнем
    # Використовуємо list comprehansive для фільтрації
    return [log for log in logs if log['level'].lower() == level.lower()]

def count_logs_by_level(logs: list) -> dict:
    """ Функція для підрахунку кількості записів за рівнем логування.
    Параметри:
    logs (list): Список логів, кожен з яких є словником.
    Повертає:
    dict: Словник, де ключі - рівні логування, а значення - кількість записів для кожного рівня."""
    # Ініціалізуємо словник для підрахунку рівнів логування
    counts = {}
    # Проходимо по кожному запису в списку logs
    # Підраховуємо кількість записів для кожного рівня логування
    for log in logs:
        level = log['level'].upper()
        if level not in counts:
            counts[level] = 0
        counts[level] += 1
    return counts

def display_log_counts(counts: dict):
    """ Функція для виведення результатів підрахунку логів у вигляді таблиці.
    Параметри:
    counts (dict): Словник з підрахунками логів за рівнями."""
    # Виводимо заголовок таблиці (перша колонка - до 20 символів, друга - до 10 символів)
    print(f"{'Рівень логування':<20} | {'Кількість':<10}")
    print('-' * 35)
    # Виводимо кожен рівень логування та його кількість зі словника counts
    for level_name, count in counts.items():
        print(f"{level_name:<20} | {count:<10}")
    print()

def input_error(func):
    """ Декоратор для обробки помилок введення користувача.
    Параметри:
    func (function): Функція, яку потрібно обгорнути декоратором.
    Повертає:
    function: Функція, яка обробляє помилки введення та повертає результат."""
    def inner(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except ValueError as ve:
            # Обробка помилок, пов'язаних з неправильним введенням
            return f"Input error: {str(ve)}"
        except KeyError as ke:
            # Обробка помилок, пов'язаних з відсутніми ключами в словнику
            return f"Key error: {str(ke)}"
        except FileNotFoundError as fnf_error:
            # Обробка помилок, пов'язаних з відсутністю файлу
            return f"File not found: {str(fnf_error)}"
        except Exception as e:
            # Обробка інших винятків
            return f"An unexpected error occurred: {str(e)}"
    return inner

@input_error
# Огортаємо головну функцію декоратором input_error
def main(file_path: str, level: str = None):
    """ Головна функція для запуску скрипту.
    Параметри:
    file_path (str): Шлях до файлу з логами.
    level (str): Необов'язковий рівень логування для фільтрації записів."""
    
    # Викликаємо функцію для завантаження логів з файлу
    logs = load_logs(file_path)
    # Викликаємо функцію для підрахунку записів за рівнем логування
    counts = count_logs_by_level(logs)
    # Викликаємо функцію для виведення результатів підрахунку
    display_log_counts(counts)
    # Якщо рівень логування вказано, фільтруємо логи за цим рівнем
    if level:
        # Викликаємо функцію для фільтрації логів за рівнем
        filtered_logs = filter_logs_by_level(logs, level)
        # Якщо є відфільтровані логи, виводимо їх деталі
        if filtered_logs:
            print(f"Деталі логів для рівня '{level}':")
            for log in filtered_logs:
                print(f"{log['date']} {log['time']} - {log['message']}")
        else:
            print(f"Немає записів для рівня '{level}'.")
    else:
        print("Будь ласка, вкажіть рівень логування для фільтрації записів.")

# Основна точка входу в програму
if __name__ == "__main__":
    import sys
    # Перевіряємо, чи вказано шлях до файлу з логами
    # Якщо аргументів менше 2, виводимо повідомлення про помилку
    # Якщо вказано рівень логування, передаємо його як другий аргумент
    # Якщо аргументів більше 2, вказуємо рівень логування
    if len(sys.argv) < 2:
        print("Будь ласка, вкажіть шлях до файлу з логами.")
    else:
        file_path = sys.argv[1]
        level = sys.argv[2] if len(sys.argv) > 2 else None
        
        # Викликаємо головну функцію main з переданими аргументами
        # Передаємо шлях до файлу та рівень логування (якщо вказано)
        result = main(file_path, level)
        
        # Якщо результат - рядок, виводимо його
        # Це може бути повідомлення про помилку або None
        if isinstance(result, str):
            print(result)
        # Якщо результат - None, нічого не виводимо
        # Це означає, що все виконано успішно без помилок
        
        
            

    
    